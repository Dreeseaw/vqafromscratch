<h1>VAE Experiment Tracker</h1>

<div>Loss</div>
<canvas id="plot_l" width="800" height="220"></canvas>

<div>Recon / RL</div>
<canvas id="plot_rl" width="800" height="200"></canvas>

<div>KL</div>
<canvas id="plot_kl" width="800" height="200"></canvas>

<div>MMD</div>
<canvas id="plot_mmd" width="800" height="200"></canvas>

<div>dD/dR slope (EMA-based)</div>
<canvas id="plot_slope" width="800" height="200"></canvas>

<div>Rate-Distortion scatter (outliers removed)</div>
<canvas id="plot_rd" width="800" height="320"></canvas>

<h2>Reconstructions</h2>
<h3>X, X', X'(mu)</h3>
<div id="images"></div>

<script>
const cL = document.getElementById("plot_l");
const cRL  = document.getElementById("plot_rl");
const cKL  = document.getElementById("plot_kl");
const cMMD = document.getElementById("plot_mmd");
const cS   = document.getElementById("plot_slope");
const cRD  = document.getElementById("plot_rd");

const ctxL = cL.getContext("2d");
const ctxRL  = cRL.getContext("2d");
const ctxKL  = cKL.getContext("2d");
const ctxMMD = cMMD.getContext("2d");
const ctxS   = cS.getContext("2d");
const ctxRD  = cRD.getContext("2d");

const data = [];

// -------------------------
// Basic helpers
// -------------------------
function minMax(arr) {
  let mn = Infinity, mx = -Infinity;
  for (const v of arr) { if (v < mn) mn = v; if (v > mx) mx = v; }
  if (!Number.isFinite(mn) || !Number.isFinite(mx)) return [0, 1];
  if (mn === mx) { mn -= 1; mx += 1; }
  return [mn, mx];
}

function drawAxes(ctx, canvas, xMin, xMax, yMin, yMax, xTicks = 5, yTicks = 5, xLabel = "", yLabel = "") {
  ctx.strokeStyle = "#888";
  ctx.fillStyle = "#555";
  ctx.lineWidth = 1;
  ctx.font = "10px sans-serif";

  const left = 55;
  const right = canvas.width - 20;
  const top = 20;
  const bottom = canvas.height - 35;

  // axes
  ctx.beginPath();
  ctx.moveTo(left, top);
  ctx.lineTo(left, bottom);
  ctx.lineTo(right, bottom);
  ctx.stroke();

  // y ticks
  for (let i = 0; i <= yTicks; i++) {
    const t = i / yTicks;
    const y = bottom - t * (bottom - top);
    const v = yMin + t * (yMax - yMin);

    ctx.beginPath();
    ctx.moveTo(left - 5, y);
    ctx.lineTo(left, y);
    ctx.stroke();

    ctx.fillText(v.toFixed(3), 5, y + 3);
  }

  // x ticks
  for (let i = 0; i <= xTicks; i++) {
    const t = i / xTicks;
    const x = left + t * (right - left);
    const v = xMin + t * (xMax - xMin);

    ctx.beginPath();
    ctx.moveTo(x, bottom);
    ctx.lineTo(x, bottom + 5);
    ctx.stroke();

    ctx.fillText(v.toFixed(2), x - 10, bottom + 15);
  }

  // labels
  if (xLabel) ctx.fillText(xLabel, (left + right) / 2 - 30, canvas.height - 8);
  if (yLabel) {
    ctx.save();
    ctx.translate(12, (top + bottom) / 2 + 30);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();
  }

  return { left, right, top, bottom };
}

function plotLine(ctx, xs, ys, xMap, yMap, color) {
  ctx.beginPath();
  ctx.strokeStyle = color;
  for (let i = 0; i < ys.length; i++) {
    const px = xMap(xs[i]);
    const py = yMap(ys[i]);
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.stroke();
}

function drawSingleSeries(ctx, canvas, steps, series, label, color) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (series.length < 2) return;

  const left = 55;
  const right = canvas.width - 20;
  const top = 20;
  const bottom = canvas.height - 35;

  const [xMin, xMax] = minMax(steps);
  const [yMin, yMax] = minMax(series);

  const xMap = (s) => left + (s - xMin) / (xMax - xMin) * (right - left);
  const yMap = (v) => bottom - (v - yMin) / (yMax - yMin) * (bottom - top);

  drawAxes(ctx, canvas, xMin, xMax, yMin, yMax, 5, 5);
  plotLine(ctx, steps, series, xMap, yMap, color);

  ctx.fillStyle = "black";
  ctx.fillText(label, left + 5, 12);
}

// -------------------------
// EMA slope (dD/dR)
// -------------------------
function computeSlopeSeries(points, alpha = 0.01) {
  // points: [{step, D, R}]
  const eps = 1e-9;
  const outSteps = [];
  const outSlope = [];

  let init = false;
  let D_ema = 0, R_ema = 0, D_prev = 0, R_prev = 0;

  for (const p of points) {
    const { step, D, R } = p;
    if (!Number.isFinite(D) || !Number.isFinite(R)) continue;

    if (!init) {
      init = true;
      D_ema = D; R_ema = R;
      D_prev = D; R_prev = R;
      outSteps.push(step);
      outSlope.push(0);
      continue;
    }

    D_ema = alpha * D + (1 - alpha) * D_ema;
    R_ema = alpha * R + (1 - alpha) * R_ema;

    const dD = D_ema - D_prev;
    const dR = R_ema - R_prev;

    D_prev = D_ema;
    R_prev = R_ema;

    if (Math.abs(dR) < eps) continue;

    outSteps.push(step);
    outSlope.push(dD / dR);
  }

  return { outSteps, outSlope };
}

// -------------------------
// RD scatter plot
// -------------------------
function drawRDScatter(ctx, canvas, points) {
  const maxPoints = 20002;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (points.length < 5) return;

  // Use raw R=KL, D=RL
  const R = points.map(p => p.R);
  const D = points.map(p => p.D);

  // Trim to finite only
  const pts = points.filter(
    p => Number.isFinite(p.R) && Number.isFinite(p.D) && p.step < maxPoints
  );
  if (pts.length < 5) return;

  const Rs = pts.map(p => p.R);
  const Ds = pts.map(p => p.D);

  // Robust bounds (avoid 1 insane point ruining view)
  // We'll use simple percentile-like trimming by sorting.
  const sortedR = Rs.slice().sort((a,b)=>a-b);
  const sortedD = Ds.slice().sort((a,b)=>a-b);
  const pLow = 0.01, pHigh = 0.99;
  const rMin = sortedR[Math.floor(pLow * (sortedR.length - 1))];
  const rMax = sortedR[Math.floor(pHigh * (sortedR.length - 1))];
  const dMin = sortedD[Math.floor(pLow * (sortedD.length - 1))];
  const dMax = sortedD[Math.floor(pHigh * (sortedD.length - 1))];

  const { left, right, top, bottom } =
    drawAxes(ctx, canvas, rMin, rMax, dMin, dMax, 6, 6, "Rate R = KL (nats, mean)", "Distortion D = RL (mean MSE)");

  const xMap = (r) => left + (r - rMin) / (rMax - rMin) * (right - left);
  const yMap = (d) => bottom - (d - dMin) / (dMax - dMin) * (bottom - top);

  // Color by time (older = lighter, newer = darker)
  // No fancy colormap: just grayscale alpha.
  // Also sub-sample for performance if huge.
  const N = pts.length;
  const maxPts = 1000;
  const stride = Math.max(1, Math.floor(N / maxPts));

  for (let i = 0; i < maxPts; i += 1) {
    const p = pts[i];
    if (p.R < rMin || p.R > rMax || p.D < dMin || p.D > dMax) continue;

    const t = i / Math.max(1, N - 1);    // 0..1
    const alpha = 0.35 + 0.60 * t;       // old points are visible
    const size  = 1 + Math.floor(2 * t); // newer points bigger (1..3)
    ctx.fillStyle = `rgba(0,0,0,${alpha.toFixed(3)})`;

    const x = xMap(p.R);
    const y = yMap(p.D);
    ctx.fillRect(x, y, size, size);
  }
  
  function drawCentroidTrail() {
    const K = 20; // number of segments across time
    const N = pts.length;
    if (N < 50) return;

    ctx.strokeStyle = "rgba(0,0,0,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();

    for (let k = 0; k < K; k++) {
      const a = Math.floor((k / K) * N);
      const b = Math.floor(((k + 1) / K) * N);

      let sr = 0, sd = 0, c = 0;
      for (let i = a; i < b; i++) {
        const p = pts[i];
        // keep within bounds
        if (p.R < rMin || p.R > rMax || p.D < dMin || p.D > dMax) continue;
        sr += p.R; sd += p.D; c++;
      }
      if (c === 0) continue;

      const r = sr / c;
      const d = sd / c;
      const x = xMap(r);
      const y = yMap(d);

      if (k === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Mark latest centroid
    ctx.fillStyle = "rgba(0,0,0,1)";
    ctx.beginPath();
    ctx.arc(xMap(pts[N-1].R), yMap(pts[N-1].D), 4, 0, 2*Math.PI);
    ctx.fill();
  }

  drawCentroidTrail();

  // Add a tiny legend
  ctx.fillStyle = "#000";
  ctx.font = "10px sans-serif";
  ctx.fillText("darker = later steps", left + 5, top + 10);
}

// -------------------------
// Main draw
// -------------------------
function draw() {
  if (data.length < 2) return;

  const steps = data.map(d => d.step);

  const eps = 1e-12;
  const loss = data.map(d => d.loss);
  const rl = data.map(d => Math.min(d.rl, 0.6));

  // KL log view (for the KL plot only)
  const klClamp = 20.0;
  let klLog = data.map(d => Math.max(d.kl, klClamp));
  // let klLog = data.map(d => Math.log10(Math.max(d.kl, 0) + eps));

  // Weighted KL (raw)
  const mmdMulti = 10000.0;
  const mmdClamp = 1.0;
  let mmd = data.map(d => Math.min(d.mmd*mmdMulti, mmdClamp));

  // Slope series needs raw D=rl and raw R=kl
  const rdPoints = data.map(d => ({ step: d.step, D: d.rl, R: d.kl }));
  const { outSteps: slopeSteps, outSlope: slopes } = computeSlopeSeries(rdPoints, 0.01);

  // Clamp slope for readability
  const SCLAMP = 0.5;
  const slopesClamped = slopes.map(v => Math.max(-SCLAMP, Math.min(SCLAMP, v)));

  drawSingleSeries(ctxL, cL, steps, loss, "Loss", "green");
  drawSingleSeries(ctxRL, cRL, steps, rl, "Recon (mean MSE)", "blue");
  drawSingleSeries(ctxKL, cKL, steps, klLog, "KL (Clamp: "+klClamp+")", "red");
  drawSingleSeries(ctxMMD, cMMD, steps, mmd, "MMD scaled", "purple");
  drawSingleSeries(ctxS, cS, slopeSteps, slopesClamped, "dD/dR (EMA, clamped)", "black");

  // RD scatter
  drawRDScatter(ctxRD, cRD, rdPoints);
}

let lastStep = -1;
let drawQueued = false;

const evt = new EventSource("/stream");
evt.onmessage = (e) => {
  const d = JSON.parse(e.data);

  // Ignore replays / duplicates
  if (d.step <= lastStep) return;
  lastStep = d.step;

  data.push(d);

  // Coalesce bursts into one draw
  if (!drawQueued) {
    drawQueued = true;
    requestAnimationFrame(() => {
      drawQueued = false;
      draw();
    });
  }
};

// -------------------------
// Images (unchanged)
// -------------------------
const imgDiv = document.getElementById("images");
const seen = new Set();

function pruneReverseLog(files, limit) {
  if (files.length <= limit) return files.slice();

  const out = [];
  const n = files.length;

  // Always keep the first image
  out.push(files[0]);

  const remaining = limit - 1;
  if (remaining <= 0) return out;

  // Indices sampled logarithmically toward the end
  const seen = new Set([0]);

  for (let i = 0; i < remaining; i++) {
    const t = i / (remaining - 1);          // [0, 1]
    const logT = Math.log10(1 + 9 * t);     // bias toward 1
    const idx = Math.floor(logT * (n - 1));

    if (!seen.has(idx)) {
      seen.add(idx);
      out.push(files[idx]);
    }
  }

  // Ensure most recent image is always included
  if (!seen.has(n - 1)) out.push(files[n - 1]);

  // Sort to preserve chronological order
  return out.sort((a, b) => files.indexOf(a) - files.indexOf(b));
}

async function pollImages() {
  const res = await fetch("/images");
  const files = await res.json();
  const sparse_files = pruneReverseLog(files, 30);
  for (const f of sparse_files) {
    if (seen.has(f)) continue;
    seen.add(f);

    const img = document.createElement("img");
    img.src = "/img/" + f;
    img.style.maxWidth = "800px";
    img.style.display = "block";
    img.style.marginBottom = "10px";

    const label = document.createElement("div");
    label.textContent = f;
    label.style.fontFamily = "monospace";
    label.style.marginBottom = "4px";

    imgDiv.appendChild(label);
    imgDiv.appendChild(img);
  }
}

setInterval(pollImages, 2000);
</script>
